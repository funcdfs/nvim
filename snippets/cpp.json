{
    "P": {
        "prefix": "P",
        "body": [
            " $0"
        ],
        "description": "空白 "
    },
    "dbg": {
        "prefix": "dbg",
        "body": [
            "eprintln(\"{}\", $1);$0"
        ],
        "description": "dbg"
    },
    "pln": {
        "prefix": "pln",
        "body": [
            "println(\"{}\", $1);$0"
        ],
        "description": "pln"
    },
    "unordered_map": {
        "prefix": "um",
        "body": [
            "unordered_map$0"
        ],
        "description": "unordered_map"
    },
    "unordered_set": {
        "prefix": "us",
        "body": [
            "unordered_set$0"
        ],
        "description": "unordered_set"
    },
    "并查集定义类 class dsu": {
        "prefix": "class_dsu",
        "body": [
            "class DSU { // https://github.com/funcdfs",
            "   private:",
            "   vector<int> f, siz;  // father and size",
            "   public:",
            "   DSU() {}  // DSU dsu(N);",
            "   DSU(int n) { init(n); }",
            "   void init(int n) {",
            "      f.resize(n);",
            "      iota(f.begin(), f.end(), 0);",
            "      siz.assign(n, 1);",
            "   }",
            "   int find(int x) {  // dsu.find(i) == i",
            "      while (x != f[x]) {",
            "         x = f[x] = f[f[x]];",
            "      }",
            "      return x;",
            "   }",
            "   bool same(int x, int y) { return find(x) == find(y); }",
            "   bool merge(int x, int y) {  // dsu.merge(A, B);",
            "      x = find(x);",
            "      y = find(y);",
            "      if (x == y) {",
            "         return false;",
            "      }",
            "      siz[x] += siz[y];",
            "      f[y] = x;",
            "      return true;",
            "   }",
            "   int size(int x) { return siz[find(x)]; }  // s = dsu.size(i);",
            "};",
            ""
        ],
        "description": "数据结构 并查集"
    },
    "pbds 平衡树": {
        "prefix": "pbds",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>   // Common file",
            "#include <ext/pb_ds/tree_policy.hpp>       // Including tree_order_statistics_node_update",
            "using namespace __gnu_pbds;",
            "",
            "template <class T>",
            "using TreeSet = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "template <class T> ",
            "using TreeMap = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "",
            "",
            "/*",
            "If using TreeMap with less_equal:",
            "   Ranking of x:                                                 mt.order_of_key(x) + 1",
            "   Find the number with rank idx:                                *mt.find_by_order(idx)",
            "   To delete only one of multiple identical numbers:             mt.erase(st.upper_bound(x));",
            "   Predecessor is defined as the largest number less than x:     *--mt.upper_bound(x)",
            "   Successor is defined as the smallest number greater than x:   *mt.lower_bound(x)",
            "*/"
        ],
        "description": "pbds"
    },
    "safe_hs": {
        "prefix": "safe_hs",
        "body": [
            "struct safe_hash {",
            "\t\tstatic uint64_t splitmix64(uint64_t x) {",
            "\t\t\t// https://codeforces.net/blog/entry/62393",
            "\t\t\tx += 0x9e3779b97f4a7c15;",
            "\t\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "\t\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "\t\t\treturn x ^ (x >> 31);",
            "\t\t}",
            "",
            "\t\tsize_t operator()(uint64_t x) const {",
            "\t\t\tstatic const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
            "\t\t\treturn splitmix64(x + FIXED_RANDOM);",
            "\t\t}",
            "};"
        ],
        "description": "安全哈希函数"
    },
    "map[ key=pair<int,int> ][ val=int ]": {
        "prefix": "pairhash",
        "body": [
            "struct pair_hash {",
            "   template <class T1, class T2>",
            "      std::size_t operator () (const std::pair<T1,T2> &p) const {",
            "      auto h1 = std::hash<T1>{}(p.first);",
            "      auto h2 = std::hash<T2>{}(p.second);",
            "      return h1 ^ h2;",
            "   }",
            "};",
            "unordered_map<pair<int, int>, int, pair_hash> $1;$0"
        ],
        "description": "数据结构 unordered_map<pair<int,int>, int>"
    },
    "小根堆，优先弹出最小值": {
        "prefix": "minPriorityQueue",
        "body": [
            "struct MinHeapComparator {",
            "\tbool operator()(const int& a, const int& b) const {",
            "\t\treturn a > b;",
            "\t} // pop value is minimum value",
            "};",
            "priority_queue<int, vector<int>, MinHeapComparator> minPQ;"
        ],
        "description": "小根堆，优先弹出最小值"
    },
    "大根堆，优先弹出最大值": {
        "prefix": "maxPriorityQueue",
        "body": [
            "struct MaxHeapComparator {",
            "\tbool operator()(const int& a, const int& b) const {",
            "\t\treturn a < b;",
            "\t} // pop value is maxmum value",
            "};",
            "priority_queue<int, vector<int>, MaxHeapComparator> maxPQ;"
        ],
        "description": "大根堆，优先弹出最大值"
    },
    "pair<int, int> .second 最大值优先弹出,": {
        "prefix": "maxPriorityQueuePair",
        "body": [
            "struct PairMaxHeapComparator {",
            "\tbool operator()(const pair<int, int>& a, const pair<int, int>& b) const {",
            "\t\treturn a.second < b.second;",
            "\t} // pop max element.second value first",
            "};",
            "priority_queue<pair<int, int>, vector<pair<int, int>>, PairMaxHeapComparator> pairMaxPQ;"
        ],
        "description": "存储 pair<int, int>, pop max element.second value first"
    },
    "pair<int, int> .second 最小值优先弹出": {
        "prefix": "minPriorityQueuePair",
        "body": [
            "struct PairMinHeapComparator {",
            "\tbool operator()(const pair<int, int>& a, const pair<int, int>& b) const {",
            "\t\treturn a.second > b.second;",
            "\t} // pop mini element.second value first",
            "};",
            "priority_queue<pair<int, int>, vector<pair<int, int>>, PairMinHeapComparator> pairMinPQ;"
        ],
        "description": "存储 pair<int, int>, pop mini element.second value first"
    },
    "排序并去重": {
        "prefix": "unique",
        "body": [
            "// make this vector to unique vector: ",
            "sort($1.begin(), $1.end()), $1.erase(unique($1.begin(), $1.end()), $1.end());\n$0"
        ],
        "description": "数组 去重"
    },
    "翻转指定数组": {
        "prefix": "reverse",
        "body": [
            "reverse($1.begin(), $1.end());$0"
        ],
        "description": "数组 翻转"
    },
    "sort(a)": {
        "prefix": "sort",
        "body": [
            "sort($1.begin(), $1.end());$0"
        ],
        "description": "数组 排序"
    },
    "sort with $func": {
        "prefix": "sortfunc",
        "body": [
            "sort($1.begin(), $1.end(), [](const auto& x1, const auto& x2) {",
            "   return $2",
            "});\n$0"
        ],
        "description": "数组 排序"
    },
    "返回最小元素": {
        "prefix": "min_ele",
        "body": [
            "*min_element($1.begin(), $1.end());\n$0"
        ],
        "description": "缩写 min_element"
    },
    "返回最大元素": {
        "prefix": "max_ele",
        "body": [
            "*max_element($1.begin(), $1.end());\n$0"
        ],
        "description": "缩写 max_element"
    },
    "count_if(array, $val)": {
        "prefix": "countif",
        "body": [
            "count_if($1.begin(), $1.end(), [=](const auto& xx){",
            "   return $2;",
            "});\n$0"
        ],
        "description": "数组 count_if 查询"
    },
    "find_if(array, $val)": {
        "prefix": "findif",
        "body": [
            "find_if($1.begin(), $1.end(), [=](const auto& xx){",
            "   return $2;",
            "});\n$0"
        ],
        "description": "数组 find_if 查询"
    },
    "iota(a.begin(), a.end(), $val)": {
        "prefix": "iota",
        "body": [
            "iota($1.begin(), $1.end(), $2);$0"
        ],
        "description": "数组 iota"
    },
    "fill(a.begin(), a.end(), $val)": {
        "prefix": "fill",
        "body": [
            "fill($1.begin(), $1.end(), $2);$0"
        ],
        "description": "数组 iota"
    },
    "begin -> end": {
        "prefix": "all",
        "body": [
            "$1.begin(), $1.end()$0"
        ],
        "description": "数组 all 迭代器"
    },
    "<= 的下边界 ": {
        "prefix": "lowerbound",
        "body": [
            "lower_bound($1.begin(), $1.end(), $2)$0"
        ],
        "description": "数组 二分查找"
    },
    "< 的下边界": {
        "prefix": "upperbound",
        "body": [
            "upper_bound($1.begin(), $1.end(), $2)$0"
        ],
        "description": "数组 二分查找"
    },
    "求和": {
        "prefix": "accumulate",
        "body": [
            "accumulate($1.begin(), $1.end(), int64_t(0));$0"
        ],
        "description": "数组 求和"
    },
    "int64_t": {
        "prefix": "ii",
        "body": [
            "int64"
        ],
        "description": "变量 int64 简写 iii"
    },
    "多个元素的 min": {
        "prefix": "min",
        "body": [
            "min({$1});$0"
        ],
        "description": "变量 最小值"
    },
    "多个元素的 max": {
        "prefix": "max",
        "body": [
            "max({$1});$0"
        ],
        "description": "变量 最大值"
    },
    "int32max": {
        "prefix": "int32max",
        "body": [
            "numeric_limits<int32>::max()$0"
        ],
        "description": "常量"
    },
    "int32min": {
        "prefix": "int32min",
        "body": [
            "numeric_limits<int32>::min()$0"
        ],
        "description": "常量"
    },
    "int64max": {
        "prefix": "int64max",
        "body": [
            "numeric_limits<int64>::max()$0"
        ],
        "description": "常量"
    },
    "int64min": {
        "prefix": "int64min",
        "body": [
            "numeric_limits<int64>::min()$0"
        ],
        "description": "常量"
    },
    "dxdy4": {
        "prefix": "dxdy4",
        "body": [
            "array<int, 4> dx = {-1, 1, 0, 0};",
            "array<int, 4> dy = {0, 0, -1, 1};\n"
        ],
        "description": "变量  四方向的 dx dy"
    },
    "dxdy8": {
        "prefix": "dxdy8",
        "body": [
            "array<int, 8> dx = {0, 1, 1, 1, 0, -1, -1, -1};",
            "array<int, 8> dy = {1, 1, 0, -1, -1, -1, 0, 1};\n"
        ],
        "description": "变量  八方向的 dx dy"
    },
    "fori": {
        "prefix": "fori",
        "body": [
            "for (int i = $1; i < $2; i++) {",
            "   $0",
            "}"
        ],
        "description": "缩写 循环 i"
    },
    "forj": {
        "prefix": "forj",
        "body": [
            "for (int j = $1; j < $2; j++) {",
            "   $0",
            "}"
        ],
        "description": "缩写 循环 j"
    },
    "fork": {
        "prefix": "fork",
        "body": [
            "for (int k = $1; k < $2; k++) {",
            "   $0",
            "}"
        ],
        "description": "缩写 循环 k"
    },
    "check": {
        "prefix": "check",
        "body": [
            "auto check = [&]() -> bool {",
            "   $0",
            "};",
            "",
            "if (check() == true) {",
            "   println(\"YES\");",
            "} else {",
            "   println(\"NO\");",
            "}"
        ],
        "description": "函数 判断正误 输出 YES NO"
    },
    "func": {
        "prefix": "func",
        "body": [
            "auto $1 = [=$2]($3) -> $4 { // usage: [=, &val1, &val2]",
            "   $0",
            "};"
        ],
        "description": "函数 func"
    },
    "funcdfs": {
        "prefix": "funcdfs",
        "body": [
            "function<void($3)>dfs = [&](int $2) -> void {",
            "   $1",
            "};$0"
        ],
        "description": "函数 funcdfs"
    },
    "print kickstart Case": {
        "prefix": "printcase",
        "body": [
            "print(\"Case #{0}: \", _case);$0"
        ],
        "description": "输出 C++20"
    },
    "coutYes": {
        "prefix": "coutYes",
        "body": [
            "cout << \"Yes\\n\";"
        ],
        "description": "输出 Yes 字符串"
    },
    "coutYES": {
        "prefix": "coutYES",
        "body": [
            "cout << \"YES\\n\";"
        ],
        "description": "输出 YES 字符串"
    },
    "coutNo": {
        "prefix": "coutNo",
        "body": [
            "cout << \"No\\n\";"
        ],
        "description": "输出 No 字符串"
    },
    "coutNO": {
        "prefix": "coutNO",
        "body": [
            "cout << \"NO\\n\";"
        ],
        "description": "输出 NO 字符串"
    },
    "a": {
        "prefix": "func_int64MulMod",
        "body": [
            "auto int64MulMod = [&](int64 a, int64 b, int64 p) -> int64 { // usage: int64 a*b%p",
            "\tint64 ans = 0;",
            "\twhile (b) {",
            "\t\tif (b&1 == 1) {",
            "\t\t\tans = (ans + a) % p;",
            "\t\t}",
            "\t\ta = (a+a) % p;",
            "\t\tb >>= 1;",
            "\t}",
            "\treturn ans;",
            "};"
        ],
        "description": "数学 64 位整数乘法"
    },
    "C(a,b) 从 a 个元素中选出 b 个元素的可能数": {
        "prefix": "mathCab",
        "body": [
            "auto C = [](int64_t aa, int64_t bb) -> int64_t {",
            "   int64_t ans = 1;",
            "   for (int64_t i = aa, j = 1; j <= bb; i--, j++) ans = ans * i / j;",
            "   return ans;",
            "};"
        ],
        "description": "数学 C(a,b) 从 a 个元素中选出 b 个元素的可能数"
    },
    "上下取整函数": {
        "prefix": "math_divfunc",
        "body": [
            "// 上下取整函数",
            "auto floor_div(int64_t x, int64_t y) -> int64_t {",
            "   assert(y != 0);",
            "   if (y < 0) {",
            "      y = -y;",
            "      x = -x;",
            "   }",
            "   if (x >= 0) return x / y;",
            "   return (x + 1) / y - 1;",
            "}",
            "auto ceil_div(int64_t x, int64_t y) -> int64_t {",
            "   assert(y != 0);",
            "   if (y < 0) {",
            "      y = -y;",
            "      x = -x;",
            "   }",
            "   if (x <= 0) return x / y;",
            "   return (x - 1) / y + 1;",
            "}"
        ],
        "description": "数学 div 上下取整函数"
    },
    "泛型 gcd 函数": {
        "prefix": "math_gcd",
        "body": [
            "template <typename T>",
            "T gcd(T a, T b) {",
            "   a = abs(a);",
            "   b = abs(b);",
            "   if (a < b) {",
            "      swap(a, b);",
            "   }",
            "   while (b) {",
            "      T r = a % b;",
            "      a = b;",
            "      b = r;",
            "   }",
            "   return a;",
            "}"
        ],
        "description": "数学 gcd"
    },
    "判断质数": {
        "prefix": "math_isPrime",
        "body": [
            "auto isPrime = [&](auto x) -> bool {",
            "   if (x < 2) {",
            "      return false;  // 判断是否大于 1",
            "   }",
            "   for (int i = 2; i * i <= x; i++) {",
            "      // 判断从 2 到 i - 1 是否包含 n 的约数，是的话，返回 false，",
            "      // 否则返回 true",
            "      if (x % i == 0) {",
            "         return false;",
            "      }",
            "   }",
            "   return true;",
            "};"
        ],
        "description": "数学 判断质数"
    },
    "卢卡斯函数 lucas": {
        "prefix": "math_lucas",
        "body": [
            "int factMod(int a, int k, int p) {",
            "   int res = 1 % p;",
            "   while (k) {",
            "      if (k & 1) {",
            "         res = (int64)res * a % p;",
            "      }",
            "      a = (int64)a * a % p;",
            "      k >>= 1;",
            "   }",
            "   return res;",
            "}",
            "",
            "int CabMod(int a, int b, int p) {",
            "   if (b > a) {",
            "      return 0;",
            "   }",
            "   if (b > a - b) {",
            "      b = a - b;",
            "   }",
            "   int64 x = 1, y = 1;",
            "   for (int i = 0; i < b; i++) {",
            "      x = x * (a - i) % p;",
            "      y = y * (i + 1) % p;",
            "   }",
            "   return x * factMod(y, p - 2, p) % p;",
            "}",
            "",
            "int lucas(int64 a, int64 b, int p) {",
            "   if (a < p && b < p) {",
            "      return CabMod(a, b, p);",
            "   }",
            "   return (int64)CabMod(a % p, b % p, p) * lucas(a / p, b / p, p) % p;",
            "}   // lucas(a, b, p)  ==  C(a, b) mod p"
        ],
        "description": "数学 lucas"
    },
    "Graph": {
        "prefix": "class_graph",
        "body": [
            "class Graph {",
            "\tpublic:",
            "\t\tGraph(int n) : n(n), e(n) {}",
            "",
            "\t\tvoid addEdge(int u, int v) {",
            "\t\t\te[u].push_back(v);",
            "\t\t\te[v].push_back(u);",
            "\t\t}",
            "",
            "\t\tbool hasEdge(int u, int v) const {",
            "\t\t\tfor (int neighbor : e[u]) {",
            "\t\t\t\tif (neighbor == v) {",
            "\t\t\t\t\treturn true;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\treturn false;",
            "\t\t}",
            "",
            "\t\tconst vector<int>& getNeighbors(int u) const {",
            "\t\t\treturn e[u];",
            "\t\t}",
            "\t\tint n; ",
            "\t\tvector<vector<int>> e;  ",
            "};"
        ],
        "description": "图论, 基础图"
    },
    "取模类 宏定义代码": {
        "prefix": "Modular_DefineCode",
        "body": [
            "",
            "",
            "#pragma region Modular_DefineCode // clang-format off",
            "template <typename T> T inverse(T a, T m) {",
            "   T u = 0, v = 1; while (a != 0) { T t = m / a;",
            "   m -= t * a; swap(a, m); u -= t * v; swap(u, v); }",
            "   assert(m == 1); return u; }",
            "template <typename T> class Modular { public:",
            "   using Type = typename decay<decltype(T::value)>::type;",
            "   constexpr Modular() : value() {}",
            "   template <typename U> Modular(const U& x) { value = normalize(x); }",
            "   template <typename U> static Type normalize(const U& x) { Type v; ",
            "      if (-mod() <= x && x < mod()) { v = static_cast<Type>(x); }",
            "      else {v = static_cast<Type>(x % mod());} if (v < 0) v += mod(); return v; }",
            "   const Type& operator()() const { return value; }",
            "   template <typename U> explicit operator U() const { return static_cast<U>(value); }",
            "   constexpr static Type mod() { return T::value; }",
            "",
            "   Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }",
            "   Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }",
            "   template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }",
            "   template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }",
            "   Modular& operator++() { return *this += 1; }",
            "   Modular& operator--() { return *this -= 1; }",
            "   Modular operator++(int) { Modular result(*this); *this += 1; return result; }",
            "   Modular operator--(int) { Modular result(*this); *this -= 1; return result; }",
            "   Modular operator-() const { return Modular(-value); }",
            "",
            "   template <typename U = T>",
            "   typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {",
            "      value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value)); return *this; }",
            "   template <typename U = T>",
            "   typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {",
            "      long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());",
            "      value = normalize(value * rhs.value - q * mod()); return *this; }",
            "   template <typename U = T>",
            "   typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {",
            "      value = normalize(value * rhs.value); return *this; }",
            "   Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }",
            "   friend const Type& abs(const Modular& x) { return x.value; }",
            "   template <typename U> friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);",
            "   template <typename U> friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);",
            "   template <typename V, typename U> friend V& operator>>(V& stream, Modular<U>& number);",
            "",
            " private:",
            "  Type value;",
            "};",
            "",
            "template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }",
            "template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }",
            "template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }",
            "template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
            "template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }",
            "template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
            "template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }",
            "",
            "template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
            "template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
            "template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
            "template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
            "template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
            "template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
            "template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
            "template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
            "template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
            "template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
            "template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
            "template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
            "",
            "template<typename T, typename U> Modular<T> power(const Modular<T>& a, const U& b) {",
            "   assert(b >= 0); Modular<T> x = a, res = 1; U p = b;",
            "   while (p > 0) { if (p & 1) res *= x; x *= x; p >>= 1; } return res; }",
            "template <typename T> bool IsZero(const Modular<T>& number) {",
            "   return number() == 0; }",
            "template <typename T> string to_string(const Modular<T>& number) {",
            "   return to_string(number()); }",
            "",
            "// U == std::ostream? but done this way because of fastoutput",
            "template <typename U, typename T> U& operator<<(U& stream, const Modular<T>& number) {",
            "   return stream << number(); }",
            "// U == std::istream? but done this way because of fastinput",
            "template <typename U, typename T> U& operator>>(U& stream, Modular<T>& number) {",
            "   typename common_type<typename Modular<T>::Type, long long>::type x;",
            "   stream >> x; number.value = Modular<T>::normalize(x); return stream; }",
            "",
            "// inverse(a, m);     power(a, b);      C(n, k);      Fact(n); ",
            "",
            "#pragma endregion Modular_DefineCode   // clang-format on",
            "",
            "",
            "// using ModType = int64; /* dynamic mod */",
            "// // 1: change ModeType, 2: use md = xxx to set",
            "// struct VarMod { static ModType value; };",
            "// ModType VarMod::value;",
            "// ModType& md = VarMod::value;",
            "// using Mint = Modular<VarMod>;",
            "",
            "",
            "constexpr int md = ${0:1000000007;}   // 1000000007   998244353   2147483647   4294967295   9223372036854775807",
            "using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;",
            "",
            "// vector<Mint> fact(1, 1);",
            "// vector<Mint> inv_fact(1, 1);",
            "// Mint C(int n, int k) {",
            "//    if (k < 0 || k > n) {",
            "//      return 0;",
            "//    }",
            "//    while ((int) fact.size() < n + 1) {",
            "//      fact.push_back(fact.back() * (int) fact.size());",
            "//      inv_fact.push_back(1 / fact.back());",
            "//    }",
            "//    return fact[n] * inv_fact[k] * inv_fact[n - k];",
            "// }",
            "",
            "",
            "// vector<Mint> fact(1, 1);",
            "// Mint F(int n) {",
            "//    while (int(fact.size()) < n + 1) {",
            "//       fact.push_back(fact.back() * (int)fact.size());",
            "//    }",
            "//    return fact[n];",
            "// }",
            "",
            "",
            ""
        ],
        "description": "Modular_DefineCode"
    },
    "分解质数类 宏定义代码": {
        "prefix": "factorizer_DefineCode",
        "body": [
            "",
            "#pragma region factorizer_DefineCode // clang-format off",
            "",
            "namespace factorizer {   // 质数因子分解器",
            "   template <typename T> struct FactorizerVarMod { static T value; };",
            "   template <typename T> T FactorizerVarMod<T>::value;",
            "",
            "   template <typename T> ",
            "   bool IsPrime(T n, const vector<T>& bases) {",
            "      if (n < 2) { return false; } vector<T> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};",
            "      for (const T& x:small_primes){if(n%x==0){return n==x;}}if(n<31*31){return true; }",
            "      int s = 0; T d = n - 1; while ((d & 1) == 0) { d >>= 1; s++; }",
            "      FactorizerVarMod<T>::value = n; for (const T& a : bases) { if (a % n == 0) { continue; }",
            "      Modular<FactorizerVarMod<T>> cur=a;cur=power(cur,d);if(cur==1){continue;}bool witness = true;",
            "      for (int r = 0; r < s; r++) { if (cur == n - 1) { witness = false; break; } cur *= cur; }",
            "      if (witness) { return false; } } return true;",
            "   }",
            "   // 判断一个数是否为质数的函数 for int64",
            "   bool IsPrime(int64_t n) { return IsPrime(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});}",
            "   // 判断一个数是否为质数的函数 for int32",
            "   bool IsPrime(int32_t n) { return IsPrime(n, {2, 7, 61}); }",
            "",
            "   // but if you really need uint64_t version...",
            "   /*",
            "   bool IsPrime(uint64_t n) {",
            "      if (n < 2) { return false; }",
            "      vector<uint32_t> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};",
            "      for (uint32_t x : small_primes) { if (n == x) { return true; } if (n % x == 0) { return false; } }",
            "      if (n < 31 * 31) { return true; } uint32_t s = __builtin_ctzll(n - 1); uint64_t d = (n - 1) >> s;",
            "      function<bool(uint64_t)> witness = [&n, &s, &d](uint64_t a) {",
            "         uint64_t cur = 1, p = d; while (p > 0) { if (p & 1) { cur = (__uint128_t) cur * a % n; }",
            "         a = (__uint128_t) a * a % n; p >>= 1; } if (cur == 1) { return false; }",
            "         for (uint32_t r = 0; r < s; r++) { if (cur == n - 1) { return false; } cur = (__uint128_t) cur * cur % n;}",
            "         return true;",
            "      }; vector<uint64_t> bases_64bit = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};",
            "      for (uint64_t a : bases_64bit) { if (a % n == 0) { return true; } if (witness(a)) { return false;}}",
            "      return true;",
            "   }",
            "   */",
            "   // 存储范围内的所有的质数",
            "   vector<int> primes;   ",
            "   vector<int> least = {0, 1};  int precalculated = 1;",
            "   ",
            "   // 使用线性筛法筛选质数",
            "   void RunLinearSieve(int n) {",
            "      n = max(n, 1); least.assign(n + 1, 0); primes.clear();",
            "      for (int i = 2; i <= n; i++) { if (least[i] == 0) { least[i] = i; primes.push_back(i); }",
            "         for (int x : primes) { if (x > least[i] || i * x > n) { break; } least[i * x] = x; } }",
            "      precalculated = n;",
            "   }",
            "   ",
            "   // 使用慢速筛法筛选质数",
            "   void RunSlowSieve(int n) {",
            "      n = max(n, 1); least.assign(n + 1, 0);",
            "      for (int i = 2; i * i <= n; i++) { if (least[i] == 0) { for (int j = i * i; j <= n; j += i) {",
            "      if (least[j] == 0) { least[j] = i; } } } } primes.clear(); for (int i = 2; i <= n; i++) {",
            "      if (least[i] == 0) { least[i] = i; primes.push_back(i); } } precalculated = n;",
            "   }",
            "   ",
            "   // 筛选范围内的所有质数",
            "   void RunSieve(int n) {",
            "      RunLinearSieve(n);",
            "      // RunSlowSieve(n);",
            "   }",
            "   int PrimesSize() { return int(factorizer::primes.size()); }",
            "   ",
            "   // 合并两个阶乘分解结果 到一个阶乘列表",
            "   template <typename T> ",
            "   vector<pair<T, int>> MergeFactors(const vector<pair<T, int>>& a, const vector<pair<T, int>>& b) {",
            "      vector<pair<T, int>> c; int i = 0; int j = 0;",
            "      while (i < (int)a.size() || j < (int)b.size()) { if (i < (int)a.size() && j < (int)b.size() ",
            "      &&a[i].first==b[j].first){c.emplace_back(a[i].first,a[i].second+b[j].second);++i;++j; continue; }",
            "      if (j == (int)b.size() || (i < (int)a.size() && a[i].first < b[j].first)) { c.push_back(a[i++]); } ",
            "      else { c.push_back(b[j++]); }} return c;",
            "   }",
            "",
            "   // 使用 Pollard's rho 算法进行质因数分解.",
            "   template <typename T>",
            "   vector<pair<T, int>> RhoC(const T& n, const T& c) { if (n <= 1) { return {}; }",
            "      if ((n & 1) == 0) { return MergeFactors( { {2, 1} }, RhoC(n / 2, c)); }",
            "      if (IsPrime(n)) {return{{n,1}};}FactorizerVarMod<T>::value = n; Modular<FactorizerVarMod<T>> x = 2; ",
            "      Modular<FactorizerVarMod<T>> saved = 2; T power = 1; T lam = 1; while (true) { x = x * x + c;",
            "         T g=__gcd((x-saved)(),n);if(g!=1){return MergeFactors(RhoC(g,c+1),RhoC(n/g,c+1));}",
            "         if (power == lam) { saved = x; power <<= 1; lam = 0; } lam++;",
            "      } return {};",
            "   }",
            "",
            "   // 给定一个整数 N ，试快速找到它的一个因数。使用 Pollard's rho 算法进行质因数分解.",
            "   template <typename T>",
            "   vector<pair<T, int>> Rho(const T& n) { return RhoC(n, static_cast<T>(1)); }",
            "",
            "   // 将一个整数分解成分项阶乘的和 vector<pair<int, int>>",
            "   template <typename T>",
            "   vector<pair<T, int>> Factorize(T x) {",
            "      if (x <= 1) { return {}; } if (x <= precalculated) { vector<pair<T, int>> ret;",
            "      while (x > 1) { if (!ret.empty() && ret.back().first == least[x]) { ret.back().second++;",
            "      } else { ret.emplace_back(least[x], 1); } x /= least[x]; }return ret; }",
            "      if (x <= static_cast<int64_t>(precalculated) * precalculated) {",
            "      vector<pair<T, int>> ret; if (!IsPrime(x)){for(T i:primes){T t=x/i;if(i>t){break;}",
            "      if (x == t * i) { int cnt = 0; while (x % i == 0) { x /= i; cnt++; } ret.emplace_back(i, cnt);",
            "      if(IsPrime(x)){break;}}}}if(x>1){ret.emplace_back(x,1);}return ret;}return Rho(x);",
            "   }",
            "",
            "   // 根据一个分项阶乘的列表 构建出这个数字的所有质因数 vector",
            "   template <typename T>",
            "   vector<T> BuildDivisorsFromFactors(const vector<pair<T, int>>& factors) {",
            "      vector<T> divisors = {1}; for (auto& p : factors) { int sz = (int)divisors.size();",
            "      for (int i = 0; i < sz; i++) { T cur = divisors[i]; for (int j = 0; j < p.second; j++) {",
            "      cur*=p.first;divisors.push_back(cur);}}}sort(divisors.begin(),divisors.end());return divisors;",
            "   }",
            "}   // namespace factorizer",
            "",
            "#pragma endregion factorizer_DefineCode   // clang-format on",
            ""
        ],
        "description": "数学 质因子分解器 factorizer_DefineCode"
    },
    "二进制相关函数": {
        "prefix": "define_bit",
        "body": [
            "#define BitCount(a)      (int)__builtin_popcount(a)",
            "#define BitCountInt64(a) (int)__builtin_popcountll(a)",
            "#define BitAt(x, i)      (((x)>>(i))&1)",
            "#define Bit(x)           (bitset<32>(x)",
            "constexpr inline int     Log2(int64 x) { return x == 0 ? -1 : sizeof(int64) * 8 - 1 - __builtin_clzll(x); }",
            ""
        ],
        "description": "数学 二进制 define code"
    },
    "全局变量定义 片段 globalVar": {
        "prefix": "define_globalVar",
        "body": [
            "// Define global variables:",
            "const int32 MAX_N = 1e7 + 10;",
            "const int32 INF_INT_32 = 0x3f3f3f3f;",
            "const int64 INF_INT_64 = 0x3f3f3f3f3f3f3f3fll;",
            "const float64 EPS = 1e-12; ",
            "const float64 PI = 3.141592653589793;",
            "",
            "// Initialize global variables function, all initialization code for global variables:",
            "int initGlobalVar = []() {",
            "   ",
            "   $0",
            "",
            "   return 0;",
            "}();"
        ],
        "description": "globalVar"
    },
    "字符串哈希 定义代码段 StringHash": {
        "prefix": "string_StringHash",
        "body": [
            "#pragma region StringHash_DefineCode // !! don't forget        initStringHash();",
            "",
            "const int mod1 = 1e9 + 7, base1 = 27;",
            "const int mod2 = 1e9 + 9, base2 = 31;   //   31   131    13131",
            "const int maxn = 1e6 + 10;",
            "int64 val1[maxn], val2[maxn];",
            "",
            "void initStringHash() {",
            "   val1[0] = val2[0] = 1;",
            "   for (int i = 1; i < maxn; i++) {",
            "      val1[i] = val1[i - 1] * base1 % mod1;",
            "      val2[i] = val2[i - 1] * base2 % mod2;",
            "   }",
            "}",
            "",
            "struct StringHash {",
            "      string s;",
            "      vector<int64> hash1, hash2;",
            "",
            "      StringHash(string _s) : s(_s), hash1 {0}, hash2 {0} {",
            "         for (auto i : s) {",
            "            hash1.push_back((hash1.back() * base1 % mod1 + i) % mod1);",
            "            hash2.push_back((hash2.back() * base2 % mod2 + i) % mod2);",
            "         }",
            "      }",
            "",
            "      void add(string news) {",
            "         s += news;",
            "         for (auto i : news) {",
            "            hash1.push_back((hash1.back() * base1 % mod1 + i) % mod1);",
            "            hash2.push_back((hash2.back() * base2 % mod2 + i) % mod2);",
            "         }",
            "      }",
            "",
            "      pair<int64, int64> get() {",
            "         return {hash1.back(), hash2.back()};",
            "      }",
            "",
            "      pair<int64, int64> substrRange(int l, int r) {",
            "         int64 a = ((hash1[r + 1] - hash1[l] * val1[r - l + 1] % mod1) % mod1 + mod1) % mod1;",
            "         int64 b = ((hash2[r + 1] - hash2[l] * val2[r - l + 1] % mod2) % mod2 + mod2) % mod2;",
            "         return {a, b};",
            "      }",
            "",
            "      pair<int64, int64> substr(int st, int len) {",
            "         int l = st, r = st + len - 1;",
            "         int64 a = ((hash1[r + 1] - hash1[l] * val1[r - l + 1] % mod1) % mod1 + mod1) % mod1;",
            "         int64 b = ((hash2[r + 1] - hash2[l] * val2[r - l + 1] % mod2) % mod2 + mod2) % mod2;",
            "         return {a, b};",
            "      }",
            "};",
            "",
            "#pragma endregion StringHash_DefineCode   // !! don't forget        initStringHash();"
        ],
        "description": "字符串 StringHash"
    },
    "string_algo_Z_func": {
        "prefix": "string_algo_Z_func",
        "body": [
            "// z[x] 计算 s[x:] 和 s[0:] 的最长公共前缀的长度，z[0] = 0。（例如 abacaba -> 0010301）。 O(n) 复杂度",
            "template <typename T>",
            "vector<int> z_func(int n, const T &s) {",
            "   vector<int> z(n, n);",
            "   int l = 0, r = 0;",
            "   for (int i = 1; i < n; i++) {",
            "      z[i] = (i > r ? 0 : min(r - i + 1, z[i - l]));",
            "      while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
            "         z[i]++;",
            "      }",
            "      if (i + z[i] - 1 > r) {",
            "         l = i;",
            "         r = i + z[i] - 1;",
            "      }",
            "   }",
            "   return z;",
            "}",
            "",
            "template <typename T>",
            "vector<int> z_func(const T &s) {",
            "   return z_function(int(s.size()), s);",
            "}"
        ],
        "description": "字符串 string_algo_Z_func"
    },
    "string_algo_construct_prefix": {
        "prefix": "string_algo_construct_prefix",
        "body": [
            "// max len of ( s[0:k-1] == s[i-(k-1):i] ) time: O(N) eg: \"aabaaab\" 0 1 0 1 2 2 3",
            "vector<int> construct_prefix(string s) {",
            "   const int n = int(s.size());",
            "   vector<int> pi(n);",
            "   for (int i = 1; i < n; i++) {",
            "      int j = pi[i - 1];",
            "      while (j > 0 && s[i] != s[j]) {",
            "         j = pi[j - 1];",
            "      }",
            "      if (s[i] == s[j]) {",
            "         j++;",
            "      }",
            "      pi[i] = j;",
            "   }",
            "   return pi;",
            "}"
        ],
        "description": "字符串 construct_prefix"
    },
    "string_algo_kmp": {
        "prefix": "string_algo_kmp",
        "body": [
            "// max len of ( s[0:k-1] == s[i-(k-1):i] ) time: O(N) eg: \"aabaaab\" 0 1 0 1 2 2 3 ",
            "vector<int> construct_prefix(string s) {",
            "   const int n = int(s.size());",
            "   vector<int> pi(n);",
            "   for (int i = 1; i < n; i++) {",
            "      int j = pi[i - 1];",
            "      while (j > 0 && s[i] != s[j]) {",
            "         j = pi[j - 1];",
            "      }",
            "      if (s[i] == s[j]) {",
            "         j++;",
            "      }",
            "      pi[i] = j;",
            "   }",
            "   return pi;",
            "}",
            "",
            "// KMP: 求出模式串 pattern 在字符串 text 中所有出现的位置的起始下标 time: O(N+M) space: O(N)",
            "vector<int> find_occurrences(string text, string pattern) {",
            "   string cur = pattern + '#' + text;",
            "   int sz1 = int(text.size()), sz2 = int(pattern.size());",
            "   vector<int> v;",
            "   vector<int> lps = construct_prefix(cur);",
            "   for (int i = sz2 + 1; i <= sz1 + sz2; i++) {",
            "      if (lps[i] == sz2) {",
            "         v.push_back(i - 2 * sz2);",
            "      }",
            "   }",
            "   return v;",
            "}",
            ""
        ],
        "description": "string_algo_kmp"
    },
    "author_time_comment": {
        "prefix": "author_time_comment",
        "body": [
            "/**",
            " * author: https://github.com/funcdfs",
            " * created: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
            "**/",
            ""
        ],
        "description": " github 链接 + 当前时间"
    },
    "multi_string": {
        "prefix": "multi_string",
        "body": [
            "// 重载字符串乘法运算符，使其支持重复字符串",
            "template <class T1>",
            "basic_string<T1> operator*(const basic_string<T1> &s, int m) {",
            "\tauto r = s;",
            "\tm *= s.size();",
            "\tr.resize(m);",
            "\tfor (int i = s.size(); i < m; i++) {",
            "\t\tr[i] = r[i - s.size()];",
            "\t}",
            "\treturn r;",
            "}"
        ],
        "description": "字符串乘法重载"
    },
    "using_int128": {
        "prefix": "using_int128",
        "body": [
            "using int128 =  __int128;",
            "istream &operator>>(istream &cin, int128 &x) { x = 0; static string s; cin >> s; for (char &c : s) { x = x * 10 + (c - '0'); } return cin; }",
            "ostream &operator<<(ostream &cout, int128 x) { static char s[60]; int tp = 1; s[0] = '0' + char(x % 10); while(x /= 10) { s[tp++] = '0' + char(x % 10); } while(tp--) {cout << s[tp]; } return cout;",
            "}",
            "",
            "int128 sqrt_int128(int128 n) {",
            "\tint128 lo = 0, hi = 1E16;",
            "\twhile (lo < hi) {",
            "\t\tint128 x = (lo + hi + 1) / 2;",
            "\t\tif (x * x <= n) {",
            "\t\t\tlo = x;",
            "\t\t} else {",
            "\t\t\thi = x - 1;",
            "\t\t}",
            "\t}",
            "\treturn lo;",
            "}",
            "",
            "int128 gcd_int128(int128 a, int128 b) {",
            "\twhile (b) {",
            "\t\ta %= b;",
            "\t\tstd::swap(a, b);",
            "\t}",
            "\treturn a;",
            "}",
            "",
            "",
            ""
        ],
        "description": "int128"
    },
    "cp": {
        "prefix": "cp",
        "body": [
            "#pragma region headers_and_definitions // clang-format off",
            "#include <bits/stdc++.h> ",
            "using namespace std; /* golang types */",
            "/* int  int8  int16   int32   int64  */ using int8 = signed char; using int16 = short; using int32 = int; using int64 = long long; ",
            "/* uint uint8 uint16  uint32  uint64 */ using uint8 = unsigned char; using uint16 = unsigned short; using uint32 = unsigned int; using uint64 = unsigned long long;",
            "/* byte rune  float32 float64        */ using byte = unsigned char; using rune = int; using float32 = float; using float64 = double;",
            "template <class T> istream &operator>> (istream &cin , vector<T>           &a)  { for (auto &x : a) { cin >> x; } return cin; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<T>           &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
            "template <class T> istream &operator>> (istream &cin , valarray<T>         &a)  { for (auto &x : a) { cin >> x; } return cin; }",
            "template <class T> ostream &operator<< (ostream &cout, valarray<T>         &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<vector<T>>   &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<valarray<T>> &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
            "struct __init_io { __init_io() { std::cout << fixed << setprecision(       15   ); cin.tie(nullptr); cin.exceptions(ios::badbit | ios::failbit); ios::sync_with_stdio(false);  }} _github_funcdfs; // Global instance",
            "#define endl '\\n'",
            "void solve(); int32 main() { solve(); return 0; }",
            "#ifdef LOCAL",
            "#include <algo/dbg.h>",
            "#else",
            "#define dbg(...)      ;",
            "#define eprint(...)   ;",
            "#define eprintln(...) ;",
            "#endif",
            "template<class T1, class T2> bool Min(T1& a, const T2& b) { return b < a ? a = b, true : false; }",
            "template<class T1, class T2> bool Max(T1& a, const T2& b) { return a < b ? a = b, true : false; }",
            "#pragma endregion headers_and_definitions       // clang-format on",
            "",
            "",
            "// ----------------------------- /* Start of useful functions */ -----------------------------",
            "",
            "",
            "void solve() {",
            "",
            "   $0",
            "",
            "   return;",
            "}",
            "",
            "// ----------------------------- /* End of useful functions */ -------------------------------",
            ""
        ],
        "description": "cp"
    },
    "tt": {
        "prefix": "tt",
        "body": [
            "#pragma region headers_and_definitions // clang-format off",
            "#include <bits/stdc++.h> ",
            "using namespace std; /* golang types */",
            "/* int  int8  int16   int32   int64  */ using int8 = signed char; using int16 = short; using int32 = int; using int64 = long long; ",
            "/* uint uint8 uint16  uint32  uint64 */ using uint8 = unsigned char; using uint16 = unsigned short; using uint32 = unsigned int; using uint64 = unsigned long long;",
            "/* byte rune  float32 float64        */ using byte = unsigned char; using rune = int; using float32 = float; using float64 = double;",
            "template <class T> istream &operator>> (istream &cin , vector<T>           &a)  { for (auto &x : a) { cin >> x; } return cin; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<T>           &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
            "template <class T> istream &operator>> (istream &cin , valarray<T>         &a)  { for (auto &x : a) { cin >> x; } return cin; }",
            "template <class T> ostream &operator<< (ostream &cout, valarray<T>         &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<vector<T>>   &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<valarray<T>> &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
            "struct __init_io { __init_io() { std::cout << fixed << setprecision(       15   ); cin.tie(nullptr); cin.exceptions(ios::badbit | ios::failbit); ios::sync_with_stdio(false);  }} _github_funcdfs; // Global instance",
            "#define endl '\\n'",
            "auto solve(int _case) -> void; int32 main() { int testCaseCnt = 0; cin >> testCaseCnt; for (int _case = 1; _case <= testCaseCnt; _case++) { solve(_case); } return 0; }",
            "#ifdef LOCAL",
            "#include <algo/dbg.h>",
            "#else",
            "#define dbg(...)      ;",
            "#define eprint(...)   ;",
            "#define eprintln(...) ;",
            "#endif",
            "template<class T1, class T2> bool Min(T1& a, const T2& b) { return b < a ? a = b, true : false; }",
            "template<class T1, class T2> bool Max(T1& a, const T2& b) { return a < b ? a = b, true : false; }",
            "#pragma endregion headers_and_definitions       // clang-format on",
            "",
            "// ----------------------------- /* Start of useful functions */ -----------------------------",
            "",
            "",
            "auto solve(int _case) -> void {",
            "   ",
            "   $0",
            "   ",
            "   return;",
            "}",
            "",
            "// ----------------------------- /* End of useful functions */ -------------------------------",
            ""
        ],
        "description": "tt"
    },
    "ttna": {
        "prefix": "ttna",
        "body": [
            "#pragma region headers_and_definitions // clang-format off",
            "#include <bits/stdc++.h> ",
            "using namespace std; /* golang types */",
            "/* int  int8  int16   int32   int64  */ using int8 = signed char; using int16 = short; using int32 = int; using int64 = long long; ",
            "/* uint uint8 uint16  uint32  uint64 */ using uint8 = unsigned char; using uint16 = unsigned short; using uint32 = unsigned int; using uint64 = unsigned long long;",
            "/* byte rune  float32 float64        */ using byte = unsigned char; using rune = int; using float32 = float; using float64 = double;",
            "template <class T> istream &operator>> (istream &cin , vector<T>           &a)  { for (auto &x : a) { cin >> x; } return cin; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<T>           &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
            "template <class T> istream &operator>> (istream &cin , valarray<T>         &a)  { for (auto &x : a) { cin >> x; } return cin; }",
            "template <class T> ostream &operator<< (ostream &cout, valarray<T>         &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<vector<T>>   &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<valarray<T>> &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
            "struct __init_io { __init_io() { std::cout << fixed << setprecision(       15   ); cin.tie(nullptr); cin.exceptions(ios::badbit | ios::failbit); ios::sync_with_stdio(false);  }} _github_funcdfs; // Global instance",
            "#define endl '\\n'",
            "auto solve(int _case) -> void; int32 main() { int testCaseCnt = 0; cin >> testCaseCnt; for (int _case = 1; _case <= testCaseCnt; _case++) { solve(_case); } return 0; }",
            "#ifdef LOCAL",
            "#include <algo/dbg.h>",
            "#else",
            "#define dbg(...)      ;",
            "#define eprint(...)   ;",
            "#define eprintln(...) ;",
            "#endif",
            "template<class T1, class T2> bool Min(T1& a, const T2& b) { return b < a ? a = b, true : false; }",
            "template<class T1, class T2> bool Max(T1& a, const T2& b) { return a < b ? a = b, true : false; }",
            "#pragma endregion headers_and_definitions       // clang-format on",
            "",
            "// ----------------------------- /* Start of useful functions */ -----------------------------",
            "",
            "",
            "auto solve(int _case) -> void {",
            "",
            "   int n = 0;",
            "   cin >> n;",
            "   vector<int> a(n, 0);",
            "   cin >> a;",
            "   ",
            "   $0",
            "   ",
            "   return;",
            "}",
            "",
            "// ----------------------------- /* End of useful functions */ -------------------------------",
            ""
        ],
        "description": "ttna"
    },
    "适用于旧平台的 old_cp": {
        "prefix": "old_cp",
        "body": [
            "#pragma region headers_and_definitions // clang-format off",
            "#include <bits/stdc++.h> ",
            "/* using golang types */ using namespace std; using int32 = signed; using uint32 = unsigned; using float32 = double; using int64 = long long; using uint64 = unsigned long long; using float64 = long double; ",
            "/* vec<(any)> cincout */ template <class T> istream &operator>> (istream &cin,  vector<T> &a)  { for (auto &x : a) { cin >> x; } return cin; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<T>           &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
            "template <class T> istream &operator>> (istream &cin , valarray<T>         &a)  { for (auto &x : a) { cin >> x; } return cin; }",
            "template <class T> ostream &operator<< (ostream &cout, valarray<T>         &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<vector<T>>   &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<valarray<T>> &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
            "#define endl '\\n'    /* Use '\\n' instead of std::endl to avoid unnecessary buffer flushes for performance */ ",
            "struct __init_io { __init_io() { std::cout << fixed << setprecision(       15   ); cin.tie(nullptr); cin.exceptions(ios::badbit | ios::failbit); ios::sync_with_stdio(false);  }} _github_funcdfs; // Global instance",
            "",
            "#define ssize(x) (int32)((x).size()) /* support C++20: std::ssize() feature*/",
            "template<class T> bool Min(T& a, const T& b) { return b < a ? a = b, 1 : 0; }",
            "template<class T> bool Max(T& a, const T& b) { return a < b ? a = b, 1 : 0; }",
            "",
            "void solve(); /* main --> */ int32 main() { solve(); return 0; }",
            "#pragma endregion headers_and_definitions   // clang-format on",
            "#ifdef LOCAL",
            "#include <algo/dbg.h>",
            "#else",
            "#define dbg(...)      ;",
            "#define eprint(...)   ;",
            "#define eprintln(...) ;",
            "#endif",
            "// ----------------------------- /* Start of useful functions */ -----------------------------",
            "",
            "",
            "void solve() {",
            "   ",
            "   $0",
            "   ",
            "   return;",
            "}",
            "",
            "// ----------------------------- /* End of useful functions */ -------------------------------",
            ""
        ],
        "description": "适用于旧平台的 cp"
    },
    "适用于旧平台的 old_tt": {
        "prefix": "old_tt",
        "body": [
            "#pragma region headers_and_definitions // clang-format off",
            "#include <bits/stdc++.h> ",
            "/* using golang types */ using namespace std; using int32 = signed; using uint32 = unsigned; using float32 = double; using int64 = long long; using uint64 = unsigned long long; using float64 = long double; ",
            "/* vec<(any)> cincout */ template <class T> istream &operator>> (istream &cin,  vector<T> &a)  { for (auto &x : a) { cin >> x; } return cin; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<T>           &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
            "template <class T> istream &operator>> (istream &cin , valarray<T>         &a)  { for (auto &x : a) { cin >> x; } return cin; }",
            "template <class T> ostream &operator<< (ostream &cout, valarray<T>         &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<vector<T>>   &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<valarray<T>> &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
            "#define endl '\\n'    /* Use '\\n' instead of std::endl to avoid unnecessary buffer flushes for performance */ ",
            "struct __init_io { __init_io() { std::cout << fixed << setprecision(       15   ); cin.tie(nullptr); cin.exceptions(ios::badbit | ios::failbit); ios::sync_with_stdio(false);  }} _github_funcdfs; // Global instance",
            "",
            "#define ssize(x) (int32)((x).size())",
            "template<class T> bool Min(T& a, const T& b) { return b < a ? a = b, 1 : 0; }",
            "template<class T> bool Max(T& a, const T& b) { return a < b ? a = b, 1 : 0; }",
            "",
            "auto solve(int _case) -> void; int32 main() { int testCaseCnt = 0; cin >> testCaseCnt; for (int _case = 1; _case <= testCaseCnt; _case++) { solve(_case); } return 0; }",
            "#pragma endregion headers_and_definitions   // clang-format on",
            "#ifdef LOCAL",
            "#include <algo/dbg.h>",
            "#else",
            "#define dbg(...)      ;",
            "#define eprint(...)   ;",
            "#define eprintln(...) ;",
            "#endif",
            "// ----------------------------- /* Start of useful functions */ -----------------------------",
            "",
            "auto solve(int _case) -> void {",
            "   ",
            "   $0",
            "   ",
            "   return;",
            "}",
            "",
            "// ----------------------------- /* End of useful functions */ -------------------------------",
            ""
        ],
        "description": "适用于旧平台的 old_tt"
    },
    "适用于旧平台的 old_ttna": {
        "prefix": "old_ttna",
        "body": [
            "#pragma region headers_and_definitions // clang-format off",
            "#include <bits/stdc++.h> ",
            "/* using golang types */ using namespace std; using int32 = signed; using uint32 = unsigned; using float32 = double; using int64 = long long; using uint64 = unsigned long long; using float64 = long double; ",
            "/* vec<(any)> cincout */ template <class T> istream &operator>> (istream &cin,  vector<T> &a)  { for (auto &x : a) { cin >> x; } return cin; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<T>           &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
            "template <class T> istream &operator>> (istream &cin , valarray<T>         &a)  { for (auto &x : a) { cin >> x; } return cin; }",
            "template <class T> ostream &operator<< (ostream &cout, valarray<T>         &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<vector<T>>   &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<valarray<T>> &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
            "#define endl '\\n'    /* Use '\\n' instead of std::endl to avoid unnecessary buffer flushes for performance */ ",
            "struct __init_io { __init_io() { std::cout << fixed << setprecision(       15   ); cin.tie(nullptr); cin.exceptions(ios::badbit | ios::failbit); ios::sync_with_stdio(false);  }} _github_funcdfs; // Global instance",
            "",
            "#define ssize(x) (int32)((x).size())",
            "template<class T> bool Min(T& a, const T& b) { return b < a ? a = b, 1 : 0; }",
            "template<class T> bool Max(T& a, const T& b) { return a < b ? a = b, 1 : 0; }",
            "",
            "auto solve(int _case) -> void; int32 main() { int testCaseCnt = 0; cin >> testCaseCnt; for (int _case = 1; _case <= testCaseCnt; _case++) { solve(_case); } return 0; }",
            "#pragma endregion headers_and_definitions   // clang-format on",
            "#ifdef LOCAL",
            "#include <algo/dbg.h>",
            "#else",
            "#define dbg(...)      ;",
            "#define eprint(...)   ;",
            "#define eprintln(...) ;",
            "#endif",
            "// ----------------------------- /* Start of useful functions */ -----------------------------",
            "",
            "",
            "auto solve(int _case) -> void {",
            "",
            "   int n = 0;",
            "   cin >> n;",
            "   vector<int> a(n, 0);",
            "   cin >> a;",
            "   ",
            "   $0",
            "   ",
            "   return;",
            "}",
            "",
            "// ----------------------------- /* End of useful functions */ -------------------------------",
            ""
        ],
        "description": "适用于旧平台的 old_ttna"
    },
    "lc": {
        "prefix": "lc",
        "body": [
            "#pragma region headers_and_definitions // clang-format off",
            "#include <bits/stdc++.h> ",
            "/* using golang types */ using namespace std; using int32 = signed; using uint32 = unsigned; using float32 = double; using int64 = long long; using uint64 = unsigned long long; using float64 = long double; ",
            "/* vec<(any)> cincout */ template <class T> istream &operator>> (istream &cin,  vector<T> &a)  { for (auto &x : a) { cin >> x; } return cin; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<T>           &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
            "template <class T> istream &operator>> (istream &cin , valarray<T>         &a)  { for (auto &x : a) { cin >> x; } return cin; }",
            "template <class T> ostream &operator<< (ostream &cout, valarray<T>         &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<vector<T>>   &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
            "template <class T> ostream &operator<< (ostream &cout, vector<valarray<T>> &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
            "#define endl '\\n'    /* Use '\\n' instead of std::endl to avoid unnecessary buffer flushes for performance */ ",
            "#define print(...)   cout << format(__VA_ARGS__)           /* the format string is printed to the standard output */ ",
            "#define println(...) cout << format(\"{0}\\n\", __VA_ARGS__); /* to print a single value and append a newline */",
            "struct __init_io { __init_io() { std::cout << fixed << setprecision(       15   ); cin.tie(nullptr); cin.exceptions(ios::badbit | ios::failbit); ios::sync_with_stdio(false);  }} _github_funcdfs; // Global instance",
            "#ifdef LOCAL",
            "#include <algo/dbg.h>",
            "#else",
            "#define dbg(...)      ;",
            "#define eprint(...)   ;",
            "#define eprintln(...) ;",
            "#endif",
            "#pragma endregion headers_and_definitions   // clang-format on",
            "",
            "/* -------------------- class start -------------------- */",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "$0",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "/* -------------------- class end --------------------  */",
            "",
            "",
            "#ifdef LOCAL",
            "int main() {",
            "\tSolution so;",
            "",
            "",
            "",
            "}",
            "#endif"
        ],
        "description": "lc"
    },
    "fastInput": {
        "prefix": "fastInput",
        "body": [
            "",
            "static struct FastInput {",
            "      static constexpr int BUF_SIZE = 1 << 20;",
            "      char buf[BUF_SIZE];",
            "      size_t chars_read = 0;",
            "      size_t buf_pos = 0;",
            "      FILE *in = stdin;",
            "      char cur = 0;",
            "",
            "      inline char get_char() {",
            "         if (buf_pos >= chars_read) {",
            "            chars_read = fread(buf, 1, BUF_SIZE, in);",
            "            buf_pos = 0;",
            "            buf[0] = (chars_read == 0 ? -1 : buf[0]);",
            "         }",
            "         return cur = buf[buf_pos++];",
            "      }",
            "",
            "      inline void tie(int) { }",
            "",
            "      inline explicit operator bool() {",
            "         return cur != -1;",
            "      }",
            "",
            "      inline static bool is_blank(char c) {",
            "         return c <= ' ';",
            "      }",
            "",
            "      inline bool skip_blanks() {",
            "         while (is_blank(cur) && cur != -1) {",
            "            get_char();",
            "         }",
            "         return cur != -1;",
            "      }",
            "",
            "      inline FastInput &operator>>(char &c) {",
            "         skip_blanks();",
            "         c = cur;",
            "         return *this;",
            "      }",
            "",
            "      inline FastInput &operator>>(string &s) {",
            "         if (skip_blanks()) {",
            "            s.clear();",
            "            do {",
            "               s += cur;",
            "            } while (!is_blank(get_char()));",
            "         }",
            "         return *this;",
            "      }",
            "",
            "      template <typename T>",
            "      inline FastInput &read_integer(T &n) {",
            "         // unsafe, doesn't check that characters are actually digits",
            "         n = 0;",
            "         if (skip_blanks()) {",
            "            int sign = +1;",
            "            if (cur == '-') {",
            "               sign = -1;",
            "               get_char();",
            "            }",
            "            do {",
            "               n += n + (n << 3) + cur - '0';",
            "            } while (!is_blank(get_char()));",
            "            n *= sign;",
            "         }",
            "         return *this;",
            "      }",
            "",
            "      template <typename T>",
            "      inline typename enable_if<is_integral<T>::value, FastInput &>::type operator>>(T &n) {",
            "         return read_integer(n);",
            "      }",
            "",
            "#if !defined(_WIN32) || defined(_WIN64)",
            "      inline FastInput &operator>>(__int128 &n) {",
            "         return read_integer(n);",
            "      }",
            "#endif",
            "",
            "      template <typename T>",
            "      inline typename enable_if<is_floating_point<T>::value, FastInput &>::type operator>>(T &n) {",
            "         // not sure if really fast, for compatibility only",
            "         n = 0;",
            "         if (skip_blanks()) {",
            "            string s;",
            "            (*this) >> s;",
            "            sscanf(s.c_str(), \"%lf\", &n);",
            "         }",
            "         return *this;",
            "      }",
            "} fast_input;",
            "",
            "#define cin fast_input"
        ],
        "description": "fastInput"
    },
    "fastOutput": {
        "prefix": "fastOutput",
        "body": [
            "",
            "static struct FastOutput {",
            "      static constexpr int BUF_SIZE = 1 << 20;",
            "      char buf[BUF_SIZE];",
            "      size_t buf_pos = 0;",
            "      static constexpr int TMP_SIZE = 1 << 20;",
            "      char tmp[TMP_SIZE];",
            "      FILE *out = stdout;",
            "",
            "      inline void put_char(char c) {",
            "         buf[buf_pos++] = c;",
            "         if (buf_pos == BUF_SIZE) {",
            "            fwrite(buf, 1, buf_pos, out);",
            "            buf_pos = 0;",
            "         }",
            "      }",
            "",
            "      ~FastOutput() {",
            "         fwrite(buf, 1, buf_pos, out);",
            "      }",
            "",
            "      inline FastOutput &operator<<(char c) {",
            "         put_char(c);",
            "         return *this;",
            "      }",
            "",
            "      inline FastOutput &operator<<(const char *s) {",
            "         while (*s) {",
            "            put_char(*s++);",
            "         }",
            "         return *this;",
            "      }",
            "",
            "      inline FastOutput &operator<<(const string &s) {",
            "         for (int i = 0; i < (int)s.size(); i++) {",
            "            put_char(s[i]);",
            "         }",
            "         return *this;",
            "      }",
            "",
            "      template <typename T>",
            "      inline char *integer_to_string(T n) {",
            "         // beware of TMP_SIZE",
            "         char *p = tmp + TMP_SIZE - 1;",
            "         if (n == 0) {",
            "            *--p = '0';",
            "         } else {",
            "            bool is_negative = false;",
            "            if (n < 0) {",
            "               is_negative = true;",
            "               n = -n;",
            "            }",
            "            while (n > 0) {",
            "               *--p = (char)('0' + n % 10);",
            "               n /= 10;",
            "            }",
            "            if (is_negative) {",
            "               *--p = '-';",
            "            }",
            "         }",
            "         return p;",
            "      }",
            "",
            "      template <typename T>",
            "      inline typename enable_if<is_integral<T>::value, char *>::type stringify(T n) {",
            "         return integer_to_string(n);",
            "      }",
            "",
            "#if !defined(_WIN32) || defined(_WIN64)",
            "      inline char *stringify(__int128 n) {",
            "         return integer_to_string(n);",
            "      }",
            "#endif",
            "",
            "      template <typename T>",
            "      inline typename enable_if<is_floating_point<T>::value, char *>::type stringify(T n) {",
            "         sprintf(tmp, \"%.17f\", n);",
            "         return tmp;",
            "      }",
            "",
            "      template <typename T>",
            "      inline FastOutput &operator<<(const T &n) {",
            "         auto p = stringify(n);",
            "         for (; *p != 0; p++) {",
            "            put_char(*p);",
            "         }",
            "         return *this;",
            "      }",
            "} fast_output;",
            "",
            "#define cout fast_output"
        ],
        "description": "fastOutput"
    },
    "cps": {
        "prefix": "cps",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#ifdef LOCAL",
            "#include <algo/dbg.h>",
            "#else",
            "#define dbg(...)      ;",
            "#define eprint(...)   ;",
            "#define eprintln(...) ;",
            "#endif",
            "",
            "int main() {",
            "   ios::sync_with_stdio(false);",
            "   cin.tie(nullptr);",
            "   ",
            "   $0",
            "   ",
            "   return 0;",
            "}"
        ],
        "description": "Competitive Programming Simple - minimal template with bits/stdc++.h and dbg.h"
    }
}
